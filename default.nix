{ pkgs, lib, config, inputs, ... }:
{
  options.go-task = {
    enable = lib.mkOption {
      type = lib.types.bool;
      description = "Enable go-task task runner";
      default = false;
    };
    
    package = lib.mkOption {
      type = lib.types.package;
      default = pkgs.go-task;
      defaultText = lib.literalExpression "pkgs.go-task";
      description = "The go-task package to use";
    };
    
    taskfile = lib.mkOption {
      type = lib.types.str;
      description = "Path to the taskfile to generate";
      default = "Taskfile.dist.yml";
    };
    
    settings = lib.mkOption {
      type = lib.types.submodule {
        options = {
          version = lib.mkOption {
            type = lib.types.str;
            description = "Taskfile version";
            default = "3";
          };
          
          vars = lib.mkOption {
            type = lib.types.attrsOf lib.types.str;
            description = "Global variables";
            default = {};
          };
          
          env = lib.mkOption {
            type = lib.types.attrsOf lib.types.str;
            description = "Global environment variables";
            default = {};
          };
          
          dotenv = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            description = "Dotenv files to load";
            default = [];
          };
          
          output = lib.mkOption {
            type = lib.types.nullOr (lib.types.enum ["interleaved" "group" "prefixed"]);
            description = "Output mode for parallel tasks";
            default = null;
          };
          
          silent = lib.mkOption {
            type = lib.types.bool;
            description = "Global silent mode";
            default = false;
          };
        };
      };
      description = "Global taskfile settings";
      default = {};
    };
    
    tasks = lib.mkOption {
      type = lib.types.attrsOf (lib.types.submodule {
        options = {
          desc = lib.mkOption {
            type = lib.types.nullOr lib.types.str;
            description = "Task description";
            default = null;
          };
          
          cmds = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            description = "Commands to run for this task";
            default = [];
          };
          
          deps = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            description = "Task dependencies";
            default = [];
          };
          
          sources = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            description = "Source files that trigger task execution";
            default = [];
          };
          
          generates = lib.mkOption {
            type = lib.types.listOf lib.types.str;
            description = "Files generated by this task";
            default = [];
          };
          
          vars = lib.mkOption {
            type = lib.types.attrsOf lib.types.str;
            description = "Task-specific variables";
            default = {};
          };
          
          env = lib.mkOption {
            type = lib.types.attrsOf lib.types.str;
            description = "Task-specific environment variables";
            default = {};
          };
          
          silent = lib.mkOption {
            type = lib.types.bool;
            description = "Whether to suppress command output";
            default = false;
          };
          
          method = lib.mkOption {
            type = lib.types.nullOr (lib.types.enum ["checksum" "timestamp" "none"]);
            description = "Method used to check if task is up-to-date";
            default = null;
          };
          
          dir = lib.mkOption {
            type = lib.types.nullOr lib.types.str;
            description = "Directory to run the task in";
            default = null;
          };
          
          preconditions = lib.mkOption {
            type = lib.types.listOf (lib.types.submodule {
              options = {
                sh = lib.mkOption {
                  type = lib.types.str;
                  description = "Shell command to check";
                };
                msg = lib.mkOption {
                  type = lib.types.nullOr lib.types.str;
                  description = "Error message if precondition fails";
                  default = null;
                };
              };
            });
            description = "Task preconditions";
            default = [];
          };
        };
      });
      description = "Task definitions";
      default = {};
    };
  };

  config =
    let
      cfg = config.go-task;
      
      # Convert preconditions to YAML format
      preconditionToYaml = precond: {
        sh = precond.sh;
      } // lib.optionalAttrs (precond.msg != null) {
        msg = precond.msg;
      };
      
      # Convert task configuration to YAML format
      taskToYaml = name: task: {
        ${name} = lib.filterAttrs (n: v: v != null && v != [] && v != {} && v != false) {
          desc = task.desc;
          cmds = if task.cmds != [] then task.cmds else null;
          deps = if task.deps != [] then task.deps else null;
          sources = if task.sources != [] then task.sources else null;
          generates = if task.generates != [] then task.generates else null;
          vars = if task.vars != {} then task.vars else null;
          env = if task.env != {} then task.env else null;
          silent = if task.silent then true else null;
          method = task.method;
          dir = task.dir;
          preconditions = if task.preconditions != [] then (map preconditionToYaml task.preconditions) else null;
        };
      };
      
      # Generate the complete taskfile content
      taskfileContent = lib.filterAttrs (n: v: v != null && v != [] && v != {} && v != false) {
        version = cfg.settings.version;
        vars = if cfg.settings.vars != {} then cfg.settings.vars else null;
        env = if cfg.settings.env != {} then cfg.settings.env else null;
        dotenv = if cfg.settings.dotenv != [] then cfg.settings.dotenv else null;
        output = cfg.settings.output;
        silent = if cfg.settings.silent then true else null;
        tasks = lib.foldl' (acc: name: acc // (taskToYaml name cfg.tasks.${name})) {} (lib.attrNames cfg.tasks);
      };
      
      # Convert to YAML string
      yamlContent = lib.generators.toYAML {} taskfileContent;
      
      # Create the taskfile
      taskfileFile = pkgs.writeText "taskfile" yamlContent;
    in
      lib.mkIf cfg.enable {
        packages = [ cfg.package ];
        
        enterShell = lib.mkAfter ''
          # Copy the generated taskfile to the project directory
          if [ ! -z "${cfg.taskfile}" ] && [ -n "${toString (lib.attrNames cfg.tasks)}" ]; then
            cp ${taskfileFile} "${cfg.taskfile}"
            echo "Generated ${cfg.taskfile} with ${toString (lib.length (lib.attrNames cfg.tasks))} tasks"
          fi
        '';
      };
}